# Snippets for Go

# Organized to reflect the sectioning of the Go spec found here: https://golang.org/ref/spec

priority -10

# Types
snippet type "aggregate type definition"
type (
	${1:A} ${2:type}
)
endsnippet

## Boolean types
snippet t "true"
true
endsnippet

snippet f "false"
false
endsnippet

## Array types
snippet a "array type"
[${1:}]${2:type}
endsnippet

snippet al "array literal"
[${1:}]${2:type}{${3:values}}
endsnippet

## Slice types
snippet s "slice type"
[]${1:type}
endsnippet

snippet sl "slice literal"
[]${1:type}{${2:values}}
endsnippet

## Struct types
snippet st "struct type" 
struct {
	${1:field} ${2:type}
}
${0}
endsnippet

snippet ste "struct entry"
${1:field} ${2:type}
endsnippet

## Function types
snippet fn "function type"
func(${1:arguments}) ${2:returned}
endsnippet

## Interface types

## Map types
snippet map "map type"
map[${1:type}]${2:type}
endsnippet

## Channel types
snippet chan "channel type"
chan ${1:type}
endsnippet

snippet rchan "recieve only channel"
<-chan ${1:type}
endsnippet

snippet schan "send only channel"
chan<- ${1:type}
endsnippet

# Declarations and scope

## Constant declarations
snippet cnst "constant declaration"
const (
	${1:name} ${2:type} = ${3:value}
)
endsnippet

snippet cnste "constant declaration entry"
${1:name} ${2:type} = ${3:value}
endsnippet

#TODO: Iota

## Type declarations
snippet typea "type alias declaration"
type (
	${1:alias} = ${2:type}
)
${0}
endsnippet

snippet typeae "type alias entry"
${1:alias} = ${2:type}
endsnippet

snippet typed "type definition declaration"
type (
	${1:identifier} ${2:type}
)
${0}
endsnippet

snippet typede "type definition entry"
${1:identifier} ${2:type}
endsnippet 

## Variable declarations
snippet : "short variable definition"
${1:x} := ${2:y}
endsnippet

## Function declarations
snippet func "function declaration"
func ${1:name}(${2:args}) ${3:returned} {
	${4:action}
}
${0}
endsnippet

## Method Declarations
snippet meth "method declaration"
func (${1:reciever}) ${2:name} ${3:returned} {
	${5:action}
}
${0}
endsnippet

# Expressions

## composite literals
snippet cmpl "composite literal expression"
${1:x} := ${2:type}{${3}}
endsnippet

snippet cmplp "composite literal pointer expression"
${1:x} := &${2:type}{${3}}
endsnippet 

## function litearls
snippet funcl "composite literal function (anonymous function)"
func(${1:args}) ${2:returned} {
	${4:action}
}
${0}
endsnippet 

## simple slice expression
snippet ss "simple slice expression"
${1:x}[${2:low} : ${3:high}]
endsnippet

## full slice expression
snippet fs "full slice expression"
${1:x}[${2:low} : ${3:high} : ${4:max}]
endsnippet

## type assertion
snippet ta "type assertion"
${1:x}, ok := ${2:y}.(${3:type})
endsnippet

# Statements
## Terminating statements
snippet p "panic"
panic(${1:x})
endsnippet

## Send Statements
snippet send "send value onto channel"
${1:ch} <- ${2:${VISUAL}}
endsnippet

## IncDec statements
snippet inc "increment variable"
${1:${VISUAL:x}} += ${2:1}
endsnippet

snippet dec "increment variable"
${1:${VISUAL:x}} -= ${2:1}
endsnippet

## Assignment Statements
snippet = "sets variable equal to operand"
${1} = ${2}
endsnippet

snippet =t "tuple assignment"
${1:x}, ${2:y} = ${3:${VISUAL}}
endsnippet

snippet =b "set blank"
_ = ${1:${VISUAL}}
endsnippet

snippet =bte "blank error in tuple return"
${1:x}, _ = ${2:${VISUAL}}
endsnippet

snippet =x "swap variables"
${1:a}, ${2:b} = $2, $1
endsnippet

## If Statements
snippet if "if statement"
if ${1:x} ${2:=} ${3:y} {
	${4:action}
}
${0}
endsnippet

snippet ife "if statement with expression"
if ${1:x} := ${2:f()}; $1 ${3: > y} {
	${4:action}
}
${0}
endsnippet

## Switch Statements
snippet switch "bare switch statement"
switch {
case ${1:condition}:
	${2:action}	
}
${0}
endsnippet 

snippet switchv "switch on a variable"
switch ${1:x} {
default:
	${2:action}
case ${3:y}:
	${4:action}
}
${0}
endsnippet

snippet switchi "switch on variable with initializer"
switch ${1:x} := ${2:fn()}; $1 {
case ${3:x}:
	${4:action}
}
${0}
endsnippet

snippet tswitch "type switch"
switch ${1:x} := ${2:y}.(type) {
case ${3:z}:
	${4:action}
}
${0}
endsnippet

snippet case "case entry"
case ${1:x}:
	${2:action}
endsnippet

snippet default "default entry"
default:
	${1:action}
endsnippet

## For statements
snippet for "for statement with no condition"
for {
	${1:action}
}
${0}
endsnippet

snippet forc "for with a condition"
for ${1:x} ${2:=} ${3:x} {
	${4:action}
}
${0}
endsnippet

snippet forcc "for with a for clause"
for ${1:i} := ${2:0}; ${3:$1} ${4:<} ${5:y}; ${6:i++} { 
	${7:action}
}
${0}
endsnippet

snippet forr "for with a range statement"
for ${1:i}, ${2:x} := range ${3:y} {
	${4:action}
}
${0}
endsnippet

## Go statements
snippet g "go statement"
go ${1:x}
endsnippet

## Select statements
snippet select "select statement"
select {
case ${1:x} ${2::=} ${3:<-c}:
	${4:action}
}
${0}
endsnippet

snippet scase "select case entry"
case ${1:x} <- ${2:y}:
	${3:action}
endsnippet

## Return statements
snippet r "return"
return ${1:x}
endsnippet

## Break statements
snippet b "break"
break ${0}
endsnippet

## Continue statements
snippet c "continue"
continue ${0}
endsnippet

## Goto statements
snippet gt "goto"
goto ${1:x}
endsnippet

## Fallthrough Statements
snippet ft "fallthrough"
fallthrough
endsnippet

## Defer statements
snippet dfr "defer"
defer ${1:${VISUAL:fn()}}
endsnippet

# Built-in functions
snippet c "close"
close(${1:args})
endsnippet

snippet mk "make"
make(${1:args})
endsnippet

snippet app "append to"
${1:x} := append($1, ${2:value})
endsnippet

snippet del "delete a map element"
delete(${1:map}, ${2:key})
endsnippet

# Errors
snippet err "if err != nil; return" 
if err != nil {
	return ${1:err}
}
${0}
endsnippet

snippet erf "if err != nil; return formatted"
if err != nil {
	return fmt.Errorf(${1:err})
}
${0}
endsnippet

snippet errh  "if err != nil; handle and return"
if err != nil {
	${1:action}
	return ${1:err}
}
${0}
endsnippet

snippet errhf "if err != nil; handle and return formatted"
if err != nil {
	${1:action}
	return fmt.Errorf(${1:err})
}
${0}
endsnippet

snippet errl "if err != nil; log and return"
if err != nil {
	log.Println(${1:err})
	return ${2:err}
}
${0}
endsnippet

snippet errlf "if err != nil; log and return"
if err != nil {
	log.Printf(${1:err})
	return ${2:err}
}
${0}
endsnippet

# Printing
snippet pl "fmt.Println"
fmt.Println(${1:args})
endsnippet

snippet pf "fmt.Printf"
fmt.Printf(${1:args})
endsnippet

snippet ll "log.Println"
log.Println(${1:args})
endsnippet

snippet lf "log.Printf"
log.Printf(${1:args})
endsnippet

